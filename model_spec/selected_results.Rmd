---
title: "New results"
author: "Laura Menicacci"
date: "`r Sys.Date()`"
output: html_document
---

```{r set-options, echo=FALSE, cache=FALSE}
options(width = 3000)
```


```{r setup, include=FALSE, echo=FALSE}
knitr::opts_chunk$set(echo = TRUE, max.height = '300px', fig.width = 16, fig.height = 8) #fig.show="hold",,

library(data.table)
library(tidyverse)
library(openxlsx)
library(gets)
library(getspanel)
library(here)
library(doParallel)
library(gridExtra)
library(conflicted)
library(viridis)
library(kableExtra)
#library(gplots)

conflict_prefer("filter", "dplyr")
conflict_prefer("first", "dplyr")
conflict_prefer("lag", "dplyr")

# mod prep
new_results <- readRDS(here("model_spec/results/models_nonpat_2.RDS")) %>% 
  separate(source, into = c("dep","formula"), sep = "[~]", remove = FALSE) %>%
  mutate(dep = str_to_title(gsub("_"," ",trimws(dep))),
         formula = trimws(formula),
         mod_name = case_when(grepl("lgdp_sq", source) & grepl("lpop", source) ~ "Log controls"))
  
new_results

```

# Data description

```{r, echo = FALSE, fig.height=8,fig.width=8}

df <- read_csv(".\\model_spec\\df.csv", show_col_types = FALSE)

box_plot_by_state <- df %>% 
  group_by(state_name) %>% 
  ggplot(aes(y = patent_count)) +
  geom_boxplot(outlier.colour="red",
               outlier.size=1) +
  facet_wrap(~state_name, scales = "free_y") +
  labs(x = "", y =  "Patent count") + 
  theme_bw() + 
  ggtitle("International US patent counts (Y02E class)", subtitle = "Boxplot by State") 

box_plot_by_state

```

## Histogram & boxplot
```{r, echo=FALSE, fig.height=7,fig.width=7}

stats_pat <- df %>% # create df with stats needed: mean, median, max by state
  select(state_name, patent_count) %>% 
  group_by(state_name) %>% 
  summarise(median = median(patent_count, na.rm=TRUE), 
            mean = mean(patent_count, na.rm=TRUE), 
            q75 = quantile(patent_count, 0.75), 
            max = max(patent_count, na.rm=TRUE))

box <- stats_pat %>% 
  ggplot(aes(x = mean))+ 
  geom_boxplot(colour = "black") +
  xlab("")+
  ylab("") +
  theme_bw()

hist <- stats_pat %>% 
  ggplot(aes(x = mean)) +
  geom_histogram(bins = 51, fill = "navy", colour = "black") +
  xlab("") +
  ylab("") +
  theme_bw()


box_hist_dist <- grid.arrange(box,hist, ncol=1, nrow=2, respect = FALSE, widths = c(5), heights = c(6, 6), top = "Y02E class patent counts. State mean distribution ", bottom = "State mean patent counts")


```


## Histogram (2) binwidth = 1

```{r, echo=FALSE, fig.height=3.5,fig.width=7}
hist2 <- stats_pat %>% 
  filter(!state_name == "California") %>% 
  ggplot(aes(x = mean)) +
  geom_histogram(binwidth = 1, fill = "navy", colour = "black") +
  xlab("State mean patent counts") +
  ylab("") +
  ggtitle("Y02E class patent counts. State mean distribution - without California") +
  theme_bw()
  
hist2
```

## State mean ranking (ascending order)

```{r, echo=FALSE}

stats_pat2 <- stats_pat[order(stats_pat$mean, decreasing = FALSE),] 
  
stats_pat2 %>% 
  select(state_name, mean) %>% 
  kable(format = "html") %>% 
  kable_styling(bootstrap_options = c("hover", "responsive"), full_width = F, fixed_thead = T, position = "left") %>% 
  scroll_box(width = "300px", height = "400px")

```





```{r, include = FALSE}
# Plotting functions

f <- function(k) {
  step <- k
  function(y) seq(floor(min(y)), ceiling(max(y)), by = step)
}

# Arranges result plots (plot and plot_grid) and prints model results
# Option to suppress model results using results = FALSE is required for automatic tabsetting.
gen_p <- function(df, results = TRUE, auto = FALSE){
  if(nrow(df) == 0){return("Empty data frame. Model likely not run.")}else{
    for(i in 1:nrow(df)){
      mt <- paste0(df$state_sample[i], " (", df$year_range[i],")", "; p.value: ",df$p_val[i],  "; AR: ",df$ar[i])
      st <- paste0("Formula: ", df$source[i])
      
      res <- df %>% slice(i) %>% pull(is) %>% first
      
      pl <- res %>% 
        plot(zero_line = FALSE) +
        ggtitle(label = mt, subtitle = st) +
        scale_x_continuous(breaks = f(10))
      
      pg <- res %>%
        plot_grid() +
        ggtitle(label = mt, subtitle = st)
      grid.arrange(pl, pg, ncol = 2)
      
      if(results == TRUE & auto == FALSE){
        print(st)
        print(mt)
        print(res)
      }else if(results == TRUE & auto == TRUE){
        p <- invisible(capture.output(res$isatpanel.result))
        # Spacing included to trick knitr into reading as verbatim code.
        cat(c("                         \n", 
              "                         \n", 
              paste("                  ", st,'     \n'),
              paste("                  ", mt,'     \n'),
              paste("                  ", p,'     \n')))
      }
    }
  }
}
```

# Updates {.tabset}

 * Removed gdp squared control 
 
 * Removed fuel control. Current model specifications: 
    - patent_count ~ lgdp + lpop + lgdp_sq + avg_temp     
    - log_patent_count ~ lgdp + lpop + lgdp_sq + avg_temp
    - ihs_patent_count ~ lgdp + lpop + lgdp_sq + avg_temp
 
 * Tried out different thresholds for dropping patenting states using State *mean* of y. **Rule: if mean patent count of State is less or equal the ith percentile of the distribution of mean patent counts by State, drop**. The sampling thresholds used in the models are the following:
  
    - **us_q20**: States whose mean of y <= 20th percentile of the mean distribution of y. States removed are Alaska, Mississippi, Montana, North Dakota, West Virginia, Wyoming **(6 States)**. 
    - **us_q30**: States whose mean of y <= 30th percentile of the mean distribution of y. States  removed are Alabama, Alaska, Arkansas, Hawaii, Kansas, Louisiana, Maine, Mississippi, Montana,   Nebraska, North Dakota, South Dakota, Vermont, West Virginia, Wyoming **(15 States)**.
    - **full sample (us_all)** for comparison
    
    Also considered **us_q25**: States whose mean y <= 25th percentile of the mean distribution of y. **8 States** are included: Alaska, Mississippi, Montana, North Dakota West Virginia, Wyoming, Arkansas, Nebraska (= the 6 states included in us_q20 but + Arkansas + Nebraska). Not included this sample in the model because Arkansas and Nebraska resulted to have multiple breaks in the ihs and log specifications, and this can imply that I am potentially omitting important information for my research question.

 * **p-values**: 0.01, 0.05
 * **AR terms**: 0,1
<br>

 * Ran a model specification with **time series: 2000-2019**
 * Ran a model specification with **silenced IIS**
 
# Distribution of y (patent counts) with removed states {.tabset}

```{r, echo=FALSE, fig.height=7,fig.width=7}

nonpat_q20 <- c("Alaska", "Mississippi", "Montana", "North Dakota", "West Virginia", "Wyoming" )

nonpat_q30 <- c("Alabama", "Alaska","Arkansas",  "Hawaii","Kansas","Louisiana", "Maine", "Mississippi",   "Montana","Nebraska", "North Dakota", "South Dakota", "Vermont",  "West Virginia", "Wyoming")

p1 <- stats_pat %>% 
  ggplot(aes(x = mean)) + geom_boxplot() + ggtitle("Total distribution")


p2 <- stats_pat %>% 
  filter(!state_name %in% nonpat_q20) %>% 
  ggplot(aes(x = mean)) + 
  geom_boxplot()+
  ggtitle("Distribution removing States with mean <= 20th percentile")
  

p3 <- stats_pat %>% 
  filter(!state_name %in% nonpat_q30) %>% 
  ggplot(aes(x = mean)) + 
  geom_boxplot() +
  ggtitle("Distribution removing States with mean <= 30th percentile")

means_change_dist <- grid.arrange(p1,p2,p3, ncol=1, nrow=3, respect = FALSE,  top = "Y02E class patent counts. State mean distributions ", bottom = "State mean patent counts")
  
```

## AR0 {.tabset}

p_value = 0.01 only here

```{r ar0, echo = FALSE, results = 'asis', cache = TRUE}

 new_results %>%
  filter(ar == 0 & p_val == 0.01) %>% 
       dplyr::group_split(dep) %>%
       purrr::iwalk(.,~{
         name <- unique(.x$dep)
         cat('### ', name, '{.tabset}   \n')
              for(p in unique(.x$p_val)){
                   cat('#### ', p, '{.tabset}   \n')
                for(sm in unique(.x$state_sample)){
                   cat('##### ', sm, '{.tabset}   \n')
                   filter(.x, state_sample == sm & p_val == p) %>% gen_p(., auto = TRUE)
                cat('\n')
                cat('\n')
                }
           cat('\n')
           cat('\n')
           }
         cat('\n')
         cat('\n')
       })

```

## AR1 {.tabset}

```{r ar1, echo = FALSE, results = 'asis', cache = TRUE}

new_results %>%
  filter(ar == 1) %>%  
       dplyr::group_split(dep) %>%
       purrr::iwalk(.,~{
         name <- unique(.x$dep)
         cat('### ', name, '{.tabset}   \n')
              for(p in unique(.x$p_val)){
                   cat('#### ', p, '{.tabset}   \n')
                for(sm in unique(.x$state_sample)){
                   cat('##### ', sm, '{.tabset}   \n')
                   filter(.x, state_sample == sm & p_val == p) %>% gen_p(., auto = TRUE)
                cat('\n')
                cat('\n')
                }
           cat('\n')
           cat('\n')
           }
         cat('\n')
         cat('\n')
       })

```


# Analysis excluding 2020{.tabset} 

## AR(0) {.tabset}

```{r  ar0_2019 , echo = FALSE, results = 'asis', cache = TRUE}
# mod prep
results_2019 <- readRDS(here("model_spec/results/models_2019.RDS")) %>% 
  separate(source, into = c("dep","formula"), sep = "[~]", remove = FALSE) %>%
  mutate(dep = str_to_title(gsub("_"," ",trimws(dep))),
         formula = trimws(formula),
         mod_name = case_when(grepl("lgdp_sq", source) & grepl("lpop", source) ~ "Log controls"))
  
#results_2019

results_2019 %>%
  filter(ar == 0 & p_val == 0.01) %>% 
       dplyr::group_split(dep) %>%
       purrr::iwalk(.,~{
         name <- unique(.x$dep)
         cat('### ', name, '{.tabset}   \n')
              for(p in unique(.x$p_val)){
                   cat('#### ', p, '{.tabset}   \n')
                for(sm in unique(.x$state_sample)){
                   cat('##### ', sm, '{.tabset}   \n')
                   filter(.x, state_sample == sm & p_val == p) %>% gen_p(., auto = TRUE)
                cat('\n')
                cat('\n')
                }
           cat('\n')
           cat('\n')
           }
         cat('\n')
         cat('\n')
       })


```


## AR(1) {.tabset}

```{r  ar1_2019, echo = FALSE, results = 'asis', cache = TRUE}
results_2019 %>%
  filter(ar == 1) %>% 
       dplyr::group_split(dep) %>%
       purrr::iwalk(.,~{
         name <- unique(.x$dep)
         cat('### ', name, '{.tabset}   \n')
              for(p in unique(.x$p_val)){
                   cat('#### ', p, '{.tabset}   \n')
                for(sm in unique(.x$state_sample)){
                   cat('##### ', sm, '{.tabset}   \n')
                   filter(.x, state_sample == sm & p_val == p) %>% gen_p(., auto = TRUE)
                cat('\n')
                cat('\n')
                }
           cat('\n')
           cat('\n')
           }
         cat('\n')
         cat('\n')
       })
```

# Analysis with IIS = FALSE {.tabset}

## AR(0) {.tabset}

```{r ar0_noIIS, echo = FALSE, results = 'asis', cache = TRUE}
# mod prep
results_noIIS <- readRDS(here("model_spec/results/models_nonpat_noIIS.RDS")) %>% 
  separate(source, into = c("dep","formula"), sep = "[~]", remove = FALSE) %>%
  mutate(dep = str_to_title(gsub("_"," ",trimws(dep))),
         formula = trimws(formula),
         mod_name = case_when(grepl("lgdp_sq", source) & grepl("lpop", source) ~ "Log controls"))
  
#results_noIIS

results_noIIS %>%
  filter(ar == 0 & p_val == 0.01) %>% 
       dplyr::group_split(dep) %>%
       purrr::iwalk(.,~{
         name <- unique(.x$dep)
         cat('### ', name, '{.tabset}   \n')
              for(p in unique(.x$p_val)){
                   cat('#### ', p, '{.tabset}   \n')
                for(sm in unique(.x$state_sample)){
                   cat('##### ', sm, '{.tabset}   \n')
                   filter(.x, state_sample == sm & p_val == p) %>% gen_p(., auto = TRUE)
                cat('\n')
                cat('\n')
                }
           cat('\n')
           cat('\n')
           }
         cat('\n')
         cat('\n')
       })

```


## AR(1) {.tabset}

```{r ar1_noIIS, echo = FALSE, results = 'asis', cache = TRUE}
results_noIIS %>%
  filter(ar == 1) %>% 
       dplyr::group_split(dep) %>%
       purrr::iwalk(.,~{
         name <- unique(.x$dep)
         cat('### ', name, '{.tabset}   \n')
              for(p in unique(.x$p_val)){
                   cat('#### ', p, '{.tabset}   \n')
                for(sm in unique(.x$state_sample)){
                   cat('##### ', sm, '{.tabset}   \n')
                   filter(.x, state_sample == sm & p_val == p) %>% gen_p(., auto = TRUE)
                cat('\n')
                cat('\n')
                }
           cat('\n')
           cat('\n')
           }
         cat('\n')
         cat('\n')
       })

```

