facet_wrap(~state_name, scales = "free_y") +
labs(x = "", y =  "Patent count") +
theme_bw() +
ggtitle("International US patent counts (Y02E class)", subtitle = "Distribution by State")
box_plot_by_state
ggsave(".\\figs_new\\box_plot_by_state.png", plot = box_plot_by_state, device = "png", width = 10, height = 10)
nonpat_mean <- c() #  states
for (i in 1:nrow(stats_pat)){
if (stats_pat[i, 3] <= median){ # if mean of state is less than median of entire dist: drop
nonpat_mean <- append(nonpat_mean, stats_pat[[i, 1]])
}
}
length(nonpat_mean)
mean <- mean(df$patent_count)
nonpat_mean <- c() #  states
for (i in 1:nrow(stats_pat)){
if (stats_pat[i, 3] <= mean){ # if mean of state is less than median of entire dist: drop
nonpat_mean <- append(nonpat_mean, stats_pat[[i, 1]])
}
}
length(nonpat_mean)
mean
mean
median
y_dist <- df %>%
ggplot(aes(x = patent_count)) +
geom_histogram(fill = "navy", colour = "black") +
labs(x = "Dependent variable (y) = patent counts", y = "") +
ggtitle("Distribution of the dependent variable")+
theme_bw()
y_dist
#ggsave(".\\fig_new\\y_distribution.png", plot = y_dist, device = "png", width = 8, height = 8)
us_all <- c("Alabama", "Alaska", "Arizona", "Arkansas","California","Colorado","Connecticut", "Delaware", "Florida","Georgia","Idaho","Illinois","Indiana","Iowa","Kansas","Kentucky","Louisiana","Maine","Maryland","Massachusetts","Michigan","Minnesota","Mississippi","Missouri","Montana","Nebraska","Nevada","New Hampshire","New Jersey", "New York", "New Mexico", "North Carolina", "North Dakota","Ohio", "Oklahoma", "Oregon", "Pennsylvania", "Rhode Island", "South Carolina","South Dakota", "Tennessee", "Texas", "Utah", "Vermont", "Virginia", "Washington","West Virginia","Wisconsin","Wyoming", "District of Columbia", "Hawaii")
stats_pat <- df %>% # create df with stats needed: mean, median, max by state
select(state_name, patent_count) %>%
group_by(state_name) %>%
summarise(median = median(patent_count, na.rm=TRUE),
mean = mean(patent_count, na.rm=TRUE),
q75 = quantile(patent_count, 0.75),
max = max(patent_count, na.rm=TRUE))
stats_pat %>% ggplot(aes(x = mean)) + geom_boxplot()
stats_pat %>% ggplot(aes(x = mean)) + geom_histogram()
stats_pat %>% ggplot(aes(x = mean)) + geom_histogram(stat_bin())
stats_pat %>% ggplot(aes(x = mean)) + geom_histogram() +stat_bin()
stats_pat %>% ggplot(aes(x = mean)) + geom_histogram() + stat_bin(bins = 30)
stats_pat %>% ggplot(aes(x = mean)) + stat_bin(bins = 30)
stats_pat %>% ggplot(aes(x = mean)) + stat_bin()
bins = 3
us_all <- c("Alabama", "Alaska", "Arizona", "Arkansas","California","Colorado","Connecticut", "Delaware", "Florida","Georgia","Idaho","Illinois","Indiana","Iowa","Kansas","Kentucky","Louisiana","Maine","Maryland","Massachusetts","Michigan","Minnesota","Mississippi","Missouri","Montana","Nebraska","Nevada","New Hampshire","New Jersey", "New York", "New Mexico", "North Carolina", "North Dakota","Ohio", "Oklahoma", "Oregon", "Pennsylvania", "Rhode Island", "South Carolina","South Dakota", "Tennessee", "Texas", "Utah", "Vermont", "Virginia", "Washington","West Virginia","Wisconsin","Wyoming", "District of Columbia", "Hawaii")
stats_pat <- df %>% # create df with stats needed: mean, median, max by state
select(state_name, patent_count) %>%
group_by(state_name) %>%
summarise(median = median(patent_count, na.rm=TRUE),
mean = mean(patent_count, na.rm=TRUE),
q75 = quantile(patent_count, 0.75),
max = max(patent_count, na.rm=TRUE))
stats_pat %>% ggplot(aes(x = mean)) + geom_boxplot()
stats_pat %>% ggplot(aes(x = mean)) + stat_bin(bins = 30)
median <- median(stats_pat$mean)
median
q10 <- quantile(df$patent_count, 0.10)
q10 <- quantile(df$patent_count, 0.10)
q10
q10 <- quantile(df$patent_count, 0.10)
nonpat_q10 <- c() #  states
for (i in 1:nrow(stats_pat)){
if (stats_pat[i, 3] <= q10[[1]]){ # if mean of state is less than q10 of entire dist: drop
nonpat_q10 <- append(nonpat_q10, stats_pat[[i, 1]])
}
}
length(nonpat_q10)
nonpat_q10
q <- quantile(df$patent_count, 0.20)
nonpat_q <- c() #  states
for (i in 1:nrow(stats_pat)){
if (stats_pat[i, 3] <= q[[1]]){ # if mean of state is less than q10 of entire dist: drop
nonpat_q <- append(nonpat_q, stats_pat[[i, 1]])
}
}
q
nonpat_q
q <- quantile(df$patent_count, 0.30)
nonpat_q <- c() #  states
for (i in 1:nrow(stats_pat)){
if (stats_pat[i, 3] <= q[[1]]){ # if mean of state is less than q10 of entire dist: drop
nonpat_q <- append(nonpat_q, stats_pat[[i, 1]])
}
}
nonpat_q
length(Q)
length(q)
length(nonpat_q)
q <- quantile(df$patent_count, 0.25)
nonpat_q <- c() #  states
for (i in 1:nrow(stats_pat)){
if (stats_pat[i, 3] <= q[[1]]){ # if mean of state is less than q10 of entire dist: drop
nonpat_q <- append(nonpat_q, stats_pat[[i, 1]])
}
}
nonpat_q
length(nonpat_q)
q20 <- quantile(df$patent_count, 0.20)
nonpat_q20 <- c() #  states
for (i in 1:nrow(stats_pat)){
if (stats_pat[i, 3] <= q20[[1]]){ # if mean of state is less than q20 of entire dist: drop
nonpat_q20 <- append(nonpat_q20, stats_pat[[i, 1]])
}
}
q25 <- quantile(df$patent_count, 0.25)
nonpat_q25 <- c() #  states
for (i in 1:nrow(stats_pat)){
if (stats_pat[i, 3] <= q25[[1]]){ # if mean of state is less than q25 of entire dist: drop
nonpat_q25 <- append(nonpat_q25, stats_pat[[i, 1]])
}
}
q30 <- quantile(df$patent_count, 0.30)
nonpat_q30 <- c() #  states
for (i in 1:nrow(stats_pat)){
if (stats_pat[i, 3] <= q30[[1]]){ # if mean of state is less than q30 of entire dist: drop
nonpat_q30 <- append(nonpat_q30, stats_pat[[i, 1]])
}
}
df %>%
filter(state_name %in% nonpat_q20) %>%
ggplot(aes(x = patent_count)) +
geom_boxplot()
df %>%
filter(state_name %in% nonpat_q25) %>%
ggplot(aes(x = patent_count)) +
geom_boxplot()
df %>%
filter(state_name %in% nonpat_q30) %>%
ggplot(aes(x = patent_count)) +
geom_boxplot()
df %>%
filter(!state_name %in% nonpat_q20) %>%
ggplot(aes(x = patent_count)) +
geom_boxplot()
df %>%
filter(!state_name %in% nonpat_q25) %>%
ggplot(aes(x = patent_count)) +
geom_boxplot()
df %>%
filter(!state_name %in% nonpat_q30) %>%
ggplot(aes(x = patent_count)) +
geom_boxplot()
nonpat_q30
nonpat_q25
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(gets)
library(getspanel)
library(here)
library(doParallel)
library(readxl)
library(gdata)
us_all <- c("Alabama", "Alaska", "Arizona", "Arkansas","California","Colorado","Connecticut", "Delaware", "Florida","Georgia","Idaho","Illinois","Indiana","Iowa","Kansas","Kentucky","Louisiana","Maine","Maryland","Massachusetts","Michigan","Minnesota","Mississippi","Missouri","Montana","Nebraska","Nevada","New Hampshire","New Jersey", "New York", "New Mexico", "North Carolina", "North Dakota","Ohio", "Oklahoma", "Oregon", "Pennsylvania", "Rhode Island", "South Carolina","South Dakota", "Tennessee", "Texas", "Utah", "Vermont", "Virginia", "Washington","West Virginia","Wisconsin","Wyoming", "District of Columbia", "Hawaii")
nonpat_q20 <- c("Alabama", "Arizona", "Arkansas","California","Colorado","Connecticut", "Delaware", "Florida","Georgia","Idaho","Illinois","Indiana","Iowa","Kansas","Kentucky","Louisiana","Maine","Maryland","Massachusetts","Michigan","Minnesota","Missouri","Nebraska","Nevada","New Hampshire","New Jersey", "New York", "New Mexico", "North Carolina", "Ohio", "Oklahoma", "Oregon", "Pennsylvania", "Rhode Island", "South Carolina","South Dakota", "Tennessee", "Texas", "Utah", "Vermont", "Virginia", "Washington","Wisconsin", "District of Columbia", "Hawaii")
nonpat_q25 <- c("Alabama", "Alaska", "Arizona", "Arkansas","California","Colorado","Connecticut", "Delaware", "Florida","Georgia","Idaho","Illinois","Indiana","Iowa","Kansas","Kentucky","Louisiana","Maine","Maryland","Massachusetts","Michigan","Minnesota","Mississippi","Missouri","Montana","Nebraska","Nevada","New Hampshire","New Jersey", "New York", "New Mexico", "North Carolina", "North Dakota","Ohio", "Oklahoma", "Oregon", "Pennsylvania", "Rhode Island", "South Carolina","South Dakota", "Tennessee", "Texas", "Utah", "Vermont", "Virginia", "Washington","West Virginia","Wisconsin","Wyoming", "District of Columbia", "Hawaii")
nonpat_q30 <- c("Arizona", "Arkansas","California","Colorado","Connecticut", "Delaware", "Florida","Georgia","Idaho","Illinois","Indiana","Iowa","Maryland","Massachusetts","Michigan","Minnesota","Missouri","Nevada","New Hampshire","New Jersey", "New York", "New Mexico", "North Carolina", "Ohio", "Oklahoma", "Oregon", "Pennsylvania", "Rhode Island", "South Carolina","South Dakota", "Tennessee", "Texas", "Utah", "Vermont", "Virginia", "Washington","Wisconsin","Hawaii")
samples <- mget(c("us_all", "nonpat_q20", "nonpat_q25", "nonpat_q30"))
length(nonpat_q20)
length(nonpat_q25)
q30 <- quantile(df$patent_count, 0.30)
nonpat_q30 <- c() #  states
for (i in 1:nrow(stats_pat)){
if (stats_pat[i, 3] <= q30[[1]]){ # if mean of state is less than q30 of entire dist: drop
nonpat_q30 <- append(nonpat_q30, stats_pat[[i, 1]])
}
}
length(nonpat_q30)
lnonpat_q30
nonpat_q30
us_all <- c("Alabama", "Alaska", "Arizona", "Arkansas","California","Colorado","Connecticut", "Delaware", "Florida","Georgia","Idaho","Illinois","Indiana","Iowa","Kansas","Kentucky","Louisiana","Maine","Maryland","Massachusetts","Michigan","Minnesota","Mississippi","Missouri","Montana","Nebraska","Nevada","New Hampshire","New Jersey", "New York", "New Mexico", "North Carolina", "North Dakota","Ohio", "Oklahoma", "Oregon", "Pennsylvania", "Rhode Island", "South Carolina","South Dakota", "Tennessee", "Texas", "Utah", "Vermont", "Virginia", "Washington","West Virginia","Wisconsin","Wyoming", "District of Columbia", "Hawaii")
us_q20 <- c("Alabama", "Arizona", "Arkansas","California","Colorado","Connecticut", "Delaware", "Florida","Georgia","Idaho","Illinois","Indiana","Iowa","Kansas","Kentucky","Louisiana","Maine","Maryland","Massachusetts","Michigan","Minnesota","Missouri","Nebraska","Nevada","New Hampshire","New Jersey", "New York", "New Mexico", "North Carolina", "Ohio", "Oklahoma", "Oregon", "Pennsylvania", "Rhode Island", "South Carolina","South Dakota", "Tennessee", "Texas", "Utah", "Vermont", "Virginia", "Washington","Wisconsin", "District of Columbia", "Hawaii")
us_q25 <- c("Alabama", "Arizona", "California","Colorado","Connecticut", "Delaware", "Florida","Georgia","Idaho","Illinois","Indiana","Iowa","Kansas","Kentucky","Louisiana","Maine","Maryland","Massachusetts","Michigan","Minnesota","Missouri","Nevada","New Hampshire","New Jersey", "New York", "New Mexico", "North Carolina", "Ohio", "Oklahoma", "Oregon", "Pennsylvania", "Rhode Island", "South Carolina","South Dakota", "Tennessee", "Texas", "Utah", "Vermont", "Virginia", "Washington","Wisconsin", "District of Columbia", "Hawaii")
us_q30 <- c( "Arizona","California","Colorado","Connecticut", "Delaware", "Florida","Georgia","Idaho","Illinois","Indiana","Iowa","Kentucky","Maryland","Massachusetts","Michigan","Minnesota","Missouri","Nevada","New Hampshire","New Jersey", "New York", "New Mexico", "North Carolina", "Ohio", "Oklahoma", "Oregon", "Pennsylvania", "Rhode Island", "South Carolina", "Tennessee", "Texas", "Utah","Virginia", "Washington","Wisconsin", "District of Columbia")
samples <- mget(c("us_all", "us_q20", "us_q25", "us_q30"))
length(us_q20)
length(us_q25)
length(us_q30)
controls <- c(" ~ lgdp + lpop + lgdp_sq + avg_temp")
dep_var <- c("patent_count", "log_patent_count", "ihs_patent_count")
base_forms <- paste0(rep(dep_var, each = length(controls)), controls)
base_forms
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(gets)
library(getspanel)
library(here)
library(doParallel)
library(readxl)
library(gdata)
df <- read_csv("D:\\For_model\\final_df.csv", show_col_types = FALSE)
df2 <- df %>%
mutate(lpop = log(pop),
lgdp = log(gdp),
lfuel = log(fuel),
lgdp_sq = log(gdp)^2,
ltemp = log(avg_temp),
ihs_patent_count = asinh(patent_count), # inverse hyperbolic sine transformation
log_patent_count = log(patent_count+1)) %>% # log+1 transformation
filter(prio_year >= 2000)
# Sanity check
df2 %>% pull(state_name) %>% unique
df2 %>% filter(!complete.cases(.))
write_csv(df2, ".\\model_spec\\df.csv")
df <- read_csv("D:\\For_model\\final_df.csv", show_col_types = FALSE)
df2 <- df %>%
mutate(lpop = log(pop),
lgdp = log(gdp),
lfuel = log(fuel),
lgdp_sq = log(gdp)^2,
ltemp = log(avg_temp),
ihs_patent_count = asinh(patent_count), # inverse hyperbolic sine transformation
log_patent_count = log(patent_count+1)) %>% # log+1 transformation
filter(prio_year >= 2000)
# Sanity check
df2 %>% pull(state_name) %>% unique
df2 %>% filter(!complete.cases(.))
write_csv(df2, ".\\df.csv")
controls <- c(" ~ lgdp + lpop + lgdp_sq + avg_temp")
dep_var <- c("patent_count", "log_patent_count", "ihs_patent_count")
base_forms <- paste0(rep(dep_var, each = length(controls)), controls)
base_forms
cl <- makeCluster(6)
registerDoParallel(cl)
models <- foreach(f = base_forms, .combine = rbind, .packages = c('tidyverse', 'getspanel')) %:%
foreach(smpl = c("us_all", "us_q20", "us_q30"), .combine = rbind) %:%
foreach(a = c(0,1), .combine = rbind) %:%
#foreach(b = c(10, 20, 30), .combine = rbind) %:%
foreach(p.value = c(0.01, 0.05), .combine = rbind, .errorhandling = "remove") %dopar% {
dat <- df2 %>% filter(state_name %in% samples[[smpl]])
is <- isatpanel(
data = dat,
formula = as.formula(f),
index = c("state_name", "prio_year"),
effect = "twoways",
iis = TRUE,
fesis = TRUE,
ar = a,
t.pval = p.value,
max.block.size = 20
)
models = tibble(source = f,
state_sample = smpl,
year_range = paste0(min(df2$prio_year),":",max(df2$prio_year)),
p_val = p.value,
is = list(is),
iis = TRUE,
b_size = 20,
ar = a)
}
stopCluster(cl)
saveRDS(models, ".\\results\\models_nonpat_2.RDS")
stats_pat %>%
ggplot(aes(x = mean)) +
geom_boxplot()
stats_pat %>%
filter(!state_name %in% nonpat_q20) %>%
ggplot(aes(x = mean)) +
geom_boxplot()
stats_pat %>%
filter(!state_name %in% nonpat_q25) %>%
ggplot(aes(x = mean)) +
geom_boxplot()
stats_pat %>%
filter(!state_name %in% nonpat_q30) %>%
ggplot(aes(x = mean)) +
geom_boxplot()
nonpat_q20
stats_pat %>%
ggplot(aes(x = mean)) +
geom_boxplot()
stats_pat %>%
filter(state_name %in% nonpat_q20) %>%
ggplot(aes(x = mean)) +
geom_boxplot()
stats_pat %>%
filter(state_name %in% nonpat_q25) %>%
ggplot(aes(x = mean)) +
geom_boxplot()
stats_pat %>%
filter(state_name %in% nonpat_q30) %>%
ggplot(aes(x = mean)) +
geom_boxplot()
nonpat_q25
median <- median(df$patent_count) # median of entire distribution
######################################
nonpat_median <- c() # 24 states
for (i in 1:nrow(stats_pat)){
if (stats_pat[i, 3] <= median){  # if mean of state is less than median of entire dist: drop
nonpat_median <- append(nonpat_median, stats_pat[[i, 1]])
}
}
##################################
q20 <- quantile(df$patent_count, 0.20)
nonpat_q20 <- c() #  states
for (i in 1:nrow(stats_pat)){
if (stats_pat[i, 3] <= q20[[1]]){ # if mean of state is less than q20 of entire dist: drop
nonpat_q20 <- append(nonpat_q20, stats_pat[[i, 1]])
}
}
#################################
q25 <- quantile(df$patent_count, 0.25)
nonpat_q25 <- c() #  states
for (i in 1:nrow(stats_pat)){
if (stats_pat[i, 3] <= q25[[1]]){ # if mean of state is less than q25 of entire dist: drop
nonpat_q25 <- append(nonpat_q25, stats_pat[[i, 1]])
}
}
#################################
q30 <- quantile(df$patent_count, 0.30)
nonpat_q30 <- c() # 15
states
median <- median(df$patent_count) # median of entire distribution
######################################
nonpat_median <- c() # 24 states
for (i in 1:nrow(stats_pat)){
if (stats_pat[i, 3] <= median){  # if mean of state is less than median of entire dist: drop
nonpat_median <- append(nonpat_median, stats_pat[[i, 1]])
}
}
##################################
q20 <- quantile(df$patent_count, 0.20)
nonpat_q20 <- c() #  states
for (i in 1:nrow(stats_pat)){
if (stats_pat[i, 3] <= q20[[1]]){ # if mean of state is less than q20 of entire dist: drop
nonpat_q20 <- append(nonpat_q20, stats_pat[[i, 1]])
}
}
#################################
q25 <- quantile(df$patent_count, 0.25)
nonpat_q25 <- c() #  states
for (i in 1:nrow(stats_pat)){
if (stats_pat[i, 3] <= q25[[1]]){ # if mean of state is less than q25 of entire dist: drop
nonpat_q25 <- append(nonpat_q25, stats_pat[[i, 1]])
}
}
#################################
q30 <- quantile(df$patent_count, 0.30)
nonpat_q30 <- c() # 15
for (i in 1:nrow(stats_pat)){
if (stats_pat[i, 3] <= q30[[1]]){ # if mean of state is less than q30 of entire dist: drop
nonpat_q30 <- append(nonpat_q30, stats_pat[[i, 1]])
}
}
stats_pat %>%
ggplot(aes(x = mean)) +
geom_boxplot()
stats_pat %>%
filter(state_name %in% nonpat_q20) %>%
ggplot(aes(x = mean)) +
geom_boxplot()
stats_pat %>%
filter(state_name %in% nonpat_q25) %>%
ggplot(aes(x = mean)) +
geom_boxplot()
stats_pat %>%
filter(state_name %in% nonpat_q30) %>%
ggplot(aes(x = mean)) +
geom_boxplot()
stats_pat %>%
ggplot(aes(x = mean)) +
geom_boxplot()
stats_pat %>%
filter(!state_name %in% nonpat_q20) %>%
ggplot(aes(x = mean)) +
geom_boxplot()
stats_pat %>%
filter(!state_name %in% nonpat_q25) %>%
ggplot(aes(x = mean)) +
geom_boxplot()
stats_pat %>%
filter(!state_name %in% nonpat_q30) %>%
ggplot(aes(x = mean)) +
geom_boxplot()
knitr::opts_chunk$set(echo = TRUE, max.height = '300px', fig.width = 16, fig.height = 8) #fig.show="hold",,
library(data.table)
library(tidyverse)
library(openxlsx)
library(gets)
library(getspanel)
library(here)
library(doParallel)
library(gridExtra)
library(conflicted)
library(viridis)
#library(gplots)
conflict_prefer("filter", "dplyr")
conflict_prefer("first", "dplyr")
conflict_prefer("lag", "dplyr")
# mod prep
new_results <- readRDS(here("model_spec/results/models_nonpat.RDS")) %>%
separate(source, into = c("dep","formula"), sep = "[~]", remove = FALSE) %>%
mutate(dep = str_to_title(gsub("_"," ",trimws(dep))),
formula = trimws(formula),
mod_name = case_when(grepl("lgdp_sq", source) & grepl("lpop", source) ~ "Log controls"))
options(width = 3000)
new_results <- readRDS(here("model_spec/results/models_nonpat_2.RDS")) %>%
separate(source, into = c("dep","formula"), sep = "[~]", remove = FALSE) %>%
mutate(dep = str_to_title(gsub("_"," ",trimws(dep))),
formula = trimws(formula),
mod_name = case_when(grepl("lgdp_sq", source) & grepl("lpop", source) ~ "Log controls"))
# Plotting functions
f <- function(k) {
step <- k
function(y) seq(floor(min(y)), ceiling(max(y)), by = step)
}
# Arranges result plots (plot and plot_grid) and prints model results
# Option to suppress model results using results = FALSE is required for automatic tabsetting.
gen_p <- function(df, results = TRUE, auto = FALSE){
if(nrow(df) == 0){return("Empty data frame. Model likely not run.")}else{
for(i in 1:nrow(df)){
mt <- paste0(df$state_sample[i], " (", df$year_range[i],")", "; p.value: ",df$p_val[i],  "; AR: ",df$ar[i])
st <- paste0("Formula: ", df$source[i])
res <- df %>% slice(i) %>% pull(is) %>% first
pl <- res %>%
plot(zero_line = FALSE) +
ggtitle(label = mt, subtitle = st) +
scale_x_continuous(breaks = f(10))
pg <- res %>%
plot_grid() +
ggtitle(label = mt, subtitle = st)
grid.arrange(pl, pg, ncol = 2)
if(results == TRUE & auto == FALSE){
print(st)
print(mt)
print(res)
}else if(results == TRUE & auto == TRUE){
p <- invisible(capture.output(res$isatpanel.result))
# Spacing included to trick knitr into reading as verbatim code.
cat(c("                         \n",
"                         \n",
paste("                  ", st,'     \n'),
paste("                  ", mt,'     \n'),
paste("                  ", p,'     \n')))
}
}
}
}
new_results
new_results %>%
filter(ar == 0 & p_val == 0.01) %>%
dplyr::group_split(dep) %>%
purrr::iwalk(.,~{
name <- unique(.x$dep)
cat('### ', name, '{.tabset}   \n')
for(p in unique(.x$p_val)){
cat('#### ', p, '{.tabset}   \n')
for(sm in unique(.x$state_sample)){
cat('##### ', sm, '{.tabset}   \n')
filter(.x, state_sample == sm & p_val == p) %>% gen_p(., auto = TRUE)
cat('\n')
cat('\n')
}
cat('\n')
cat('\n')
}
cat('\n')
cat('\n')
})
new_results %>%
filter(ar == 1 & mod_name == "Log controls") %>%
dplyr::group_split(dep) %>%
purrr::iwalk(.,~{
name <- unique(.x$dep)
cat('### ', name, '{.tabset}   \n')
for(p in unique(.x$p_val)){
cat('#### ', p, '{.tabset}   \n')
for(sm in unique(.x$state_sample)){
cat('##### ', sm, '{.tabset}   \n')
filter(.x, state_sample == sm & p_val == p) %>% gen_p(., auto = TRUE)
cat('\n')
cat('\n')
}
cat('\n')
cat('\n')
}
cat('\n')
cat('\n')
})
cl <- makeCluster(6)
registerDoParallel(cl)
models <- foreach(f = base_forms, .combine = rbind, .packages = c('tidyverse', 'getspanel')) %:%
foreach(smpl = c("us_all", "us_q20", "us_q30"), .combine = rbind) %:%
foreach(a = c(0,1), .combine = rbind) %:%
#foreach(b = c(10, 20, 30), .combine = rbind) %:%
foreach(p.value = c(0.01, 0.05), .combine = rbind, .errorhandling = "remove") %dopar% {
dat <- df2 %>% filter(state_name %in% samples[[smpl]]) %>% filter(prio_year <= 2019)
is <- isatpanel(
data = dat,
formula = as.formula(f),
index = c("state_name", "prio_year"),
effect = "twoways",
iis = TRUE,
fesis = TRUE,
ar = a,
t.pval = p.value,
max.block.size = 20
)
models = tibble(source = f,
state_sample = smpl,
year_range = paste0(min(df2$prio_year),":",max(df2$prio_year)),
p_val = p.value,
is = list(is),
iis = TRUE,
b_size = 20,
ar = a)
}
stopCluster(cl)
saveRDS(models, ".\\results\\models_2019.RDS")
